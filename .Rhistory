library(devtools)
devtools::install_github("suchitm/tmvn")
library(tmvn)
?exp_rej
?tmvn
rtmvn
?rtmvn
?rtmvt
build()
library(devtools)
build()
rm(list = ls())
source("~/Dropbox/Research/trend_filtering/Code/btf_gibbs.R")
source("~/Dropbox/Research/trend_filtering/Code/btf_helpers.R")
library(dplyr)
library(lars)
library(mvtnorm)
library(invgamma)
library(SuppDists)
library(ggplot2)
library(reshape2)
theta_median = theta_upper = theta_lower = vector('list', length(n_dat))
n_dat = c(50, 500, 2500)
theta_median = theta_upper = theta_lower = vector('list', length(n_dat))
theta_median
i = 1
# initializing matricies
theta_median[[i]] = theta_upper[[i]] =
theta_lower[[i]] = matrix(nrow = n_sim, ncol = n_dat[i], NA)
rm(list = ls())
source("~/Dropbox/Research/trend_filtering/Code/btf_gibbs.R")
source("~/Dropbox/Research/trend_filtering/Code/btf_helpers.R")
library(dplyr)
library(lars)
library(mvtnorm)
library(invgamma)
library(SuppDists)
library(ggplot2)
library(reshape2)
# function to simulate the data
f_x = function(x)
{
exp(-7.5 * x) * cos(10 * pi * x)
}
# number of simulations
n_sim = 1000
# number of data points
n_dat = c(50, 500, 2500)
theta_median = theta_upper = theta_lower = vector('list', length(n_dat))
i = 1
# initializing matricies
theta_median[[i]] = theta_upper[[i]] =
theta_lower[[i]] = matrix(nrow = n_sim, ncol = n_dat[i], NA)
theta_median
theta_median[[1]]
theta_lower[[1]]
sample(1:1000, size = 1)
# initializing matricies
theta_median[[i]] = theta_upper[[i]] =
theta_lower[[i]] = matrix(nrow = n_sim, ncol = n_dat[i], NA)
seq_x = seq(0, 1, length = n_dat[i])
truth = f_x(seq_x)
btf_gibbs
i = 1
j = 1
# initializing matricies
theta_median[[i]] = theta_upper[[i]] =
theta_lower[[i]] = matrix(nrow = n_sim, ncol = n_dat[i], NA)
seq_x = seq(0, 1, length = n_dat[i])
truth = f_x(seq_x)
# simulating the data
y = truth + rnorm(n_dat[i], mean = 0, sd = 0.1)
# fitting the model with varying lambda
btf_results = btf_gibbs(y, k, iters, burn_in)
iters = 2000
burn_in = iters / 2
# simulating the data
y = truth + rnorm(n_dat[i], mean = 0, sd = 0.1)
# fitting the model with varying lambda
btf_results = btf_gibbs(y, k, iters, burn_in)
rm(list = ls())
source("~/Dropbox/Research/trend_filtering/Code/btf_gibbs.R")
source("~/Dropbox/Research/trend_filtering/Code/btf_helpers.R")
library(dplyr)
library(lars)
library(mvtnorm)
library(invgamma)
library(SuppDists)
library(ggplot2)
library(reshape2)
# function to simulate the data
f_x = function(x)
{
exp(-7.5 * x) * cos(10 * pi * x)
}
# number of simulations
n_sim = 1000
# number of data points
n_dat = c(50, 500, 2500)
# fix k and lambda
k = 2
fix_lambda = 2.5
iters = 2000
burn_in = iters / 2
theta_median = theta_upper = theta_lower = vector('list', length(n_dat))
set.seed(208)
i = 1
j = 1
# initializing matricies
theta_median[[i]] = theta_upper[[i]] =
theta_lower[[i]] = matrix(nrow = n_sim, ncol = n_dat[i], NA)
seq_x = seq(0, 1, length = n_dat[i])
truth = f_x(seq_x)
# simulating the data
y = truth + rnorm(n_dat[i], mean = 0, sd = 0.1)
# fitting the model with varying lambda
btf_results = btf_gibbs(y, k, iters, burn_in)
btf_results$theta
btf_results$theta %>% dim()
library(sparse)
# fitting the model with varying lambda
btf_results = btf_gibbs(y, k, iters, burn_in)
thetas = btf_results$theta
medians = apply(thetas, 2, median)
upper = apply(thetas, 2, FUN = function(x) quantile(x, probs = c(0.975)))
lower = apply(thetas, 2, FUN = function(x) quantile(x, probs = c(0.025)))
plot(truth, type = "l")
lines(medians, col = "red")
lines(upper, col = "red", lty = 2)
lines(lower, col = "red", lty = 2)
btf_results$lambda %>% median()
source('~/Desktop/Link to Research/trend_filtering/Code/btf_sim_study.R', echo=TRUE)
lambdas
medians
(truth - medians)^2
sum((truth - medians)^2)
plot(btf_results$theta[, 1])
plot(btf_results$theta[, 1], type = "l")
plot(btf_results$theta[, 10], type = "l")
plot(btf_results$theta[, 100], type = "l")
plot(btf_results$theta[, 45], type = "l")
plot(btf_results$theta[, 5], type = "l")
plot(truth)
lines(medians)
ptm = system.time()
Sys.time()
ptm = Sys.time()
Sys.time() - ptm
proc.time()
ptm = proc.time()
proc.time() - ptm
# for the lambda varying simulation
theta_median = theta_upper = theta_lower = vector('list', length(n_dat))
lambdas = btf_time = matrix(nrow = length(n_dat), ncol = n_sim)
theta_median_fix = theta_upper_fix = theta_lower_fix =
vector('list', length(n_dat))
# initializing matricies
theta_median[[i]] = theta_upper[[i]] =
theta_lower[[i]] = matrix(nrow = n_sim, ncol = n_dat[i], NA)
seq_x = seq(0, 1, length = n_dat[i])
truth = f_x(seq_x)
# simulating the data
y = truth + rnorm(n_dat[i], mean = 0, sd = 0.1)
# fitting the model with varying lambda
ptm = proc.time()
btf_results = btf_gibbs(y, k, iters, burn_in)
btf_time[i, j] = (proc.time() - ptm)[3]
btf_time[i, j]
thetas = btf_results$theta
medians = apply(thetas, 2, median)
upper = apply(thetas, 2, FUN = function(x) quantile(x, probs = c(0.975)))
lower = apply(thetas, 2, FUN = function(x) quantile(x, probs = c(0.025)))
theta_median[[i]][j, ] = medians
theta_upper[[i]][j, ] = upper
theta_lower[[i]][j, ] = lower
lambdas[i, j] = median(btf_results$lambda)
plot(truth)
lines(meddians)
lines(medians)
lines(upper)
lines(lower)
truth <= lower
truth <= lower & truth >= upper
truth <= upper & truth >= lower
coverage[[i]][j, ] = (truth <= upper) & (truth >= lower)
for the lambda varying simulation
theta_median = theta_upper = theta_lower =
coverage = vector('list', length(n_dat))
lambdas = btf_time = mse = matrix(nrow = length(n_dat), ncol = n_sim)
coverage[[i]][j, ] = (truth <= upper) & (truth >= lower)
coverage
i
j
theta_median[[i]] = theta_upper[[i]] =
theta_lower[[i]] = coverage = matrix(nrow = n_sim, ncol = n_dat[i], NA)
theta_median[[i]] = theta_upper[[i]] =
theta_lower[[i]] = coverage[[i]] =
matrix(nrow = n_sim, ncol = n_dat[i], NA)
coverage[[i]][j, ] = (truth <= upper) & (truth >= lower)
theta_median[[i]] = theta_upper[[i]] = theta_lower[[i]] =
coverage[[i]] = matrix(nrow = n_sim, ncol = n_dat[i], NA)
i
i = 1
# for the lambda varying simulation
theta_median = theta_upper = theta_lower =
coverage = vector('list', length(n_dat))
# initializing matricies
theta_median[[i]] = theta_upper[[i]] = theta_lower[[i]] =
coverage[[i]] = matrix(nrow = n_sim, ncol = n_dat[i], NA)
coverage[[i]][j, ] = (truth <= upper) & (truth >= lower)
coverage[[i]][j, ]
source('~/Desktop/Link to Research/trend_filtering/Code/btf_sim_study.R', echo=TRUE)
i
j
source('~/Desktop/Link to Research/trend_filtering/Code/btf_sim_study.R', echo=TRUE)
mse
mse %>% mean()
coverage
coverage %>% colSums()
coverage[[1]] %>% colMeans()
mean(coverage[[i]])
btf_time
source('~/Desktop/Link to Research/trend_filtering/Code/dual_btf.R', echo=TRUE)
time_spent
nu[i, ]
plot(nu[i,])
lines(nu[2, ], col = 2)
lines(nu[3, ], col = 3)
plot(theta[2, ])
lines(theta[3, ], col = 3)
plot(theta[2, ], col = 1)
plot(theta[2, ], col = 1, type = "l")
lines(theta[3, ], col = 3)
lines(theta[4, ], col = 4)
lines(theta[5, ], col = 5)
nu_medians = apply(nu, 2, median)
theta_temp = y - t(diff_mat) %*% nu_medians
plot(theta_temp)
plot(theta_temp, type = "l")
lines(truth)
lines(theta_medians, col = 2)
nu_lower = apply(nu, 2, FUN = function(x) quantile(x, probs = c(0.025)))
theta_lower = y - t(diff_mat) %*% nu_lower
lines(theta_lower)
nu_lower
plot(nu_lower)
plot(nu_lower, type = "l")
lines(nu_medians, col = 2)
plot(nu_medians, col = 2)
plot(nu_lower)
plot(truth)
plot(theta_lower)
plot(theta_lower)
lines(truth)
a = 3
b = 3
plot(y)
b_prior = 3
a_prior = b_prior / var(y) + 1
a_prior
bar(y)
var(y)
b_prior / a_prior
a_prior
a_prior + 1
a_prior + 2
b_prior^2 / (a_prior - 1)^2 / (a_prior - 2)
b_prior^2 / (a_prior - 1)^2 / (a_prior)
4 * var(y) / (2)^2 / 1
4 * var(y) / (2.01 - 1)^2 / (0.01)
var(y) / 1.01
var(y)
source('~/Desktop/Link to Research/trend_filtering/Code/btf_dual.R', echo=TRUE)
source('~/Desktop/Link to Research/trend_filtering/Code/btf_dual.R', echo=TRUE)
plot(y)
k
lambda
btf_dual(y, k, lambda) -> dual_results
btf_dual(y, k, lambda, verbose = T) -> dual_results
dual_results$theta %>% median() %>% lines(col = 2)
dual_results
medians = apply(dual_results, 2, median)
plot(truth, col = 1)
plot(truth, col = 1, type = "l")
lines(medians, col = 2)
upper = apply(dual_results, 2, FUN = function(x) quantile(x, probs = 0.975)
)
lines(upper, col = 2, lty = 2)
btf_dual
burn_in
iters
iters = 2000
burn_in = iters / 2
iters
burn_in
iters - burn_in
btf_dual
source('~/Desktop/Link to Research/trend_filtering/Code/btf_sim_study.R', echo=TRUE)
source('~/Desktop/Link to Research/trend_filtering/Code/btf_sim_study.R', echo=TRUE)
source('~/Desktop/Link to Research/trend_filtering/Code/btf_sim_study.R', echo=TRUE)
source('~/Desktop/Link to Research/trend_filtering/Code/btf_sim_study.R', echo=TRUE)
source('~/Desktop/Link to Research/trend_filtering/Code/btf_sim_study.R', echo=TRUE)
mse_dual
mse_vary
mse_fix
coverage_dual
coverage_dual %>% mean()
mean(coverage_dual[[1]])
mean(coverage_vary [[1]])
mean(coverage_fix[[1]])
lambda
lambdas
dual_time
btf_time
source('~/Desktop/Link to Research/trend_filtering/Code/btf_sim_study.R', echo=TRUE)
source('~/Desktop/Link to Research/trend_filtering/Code/btf_sim_study.R', echo=TRUE)
10 * 50 / 60
mse_dual
mean(mse_dual)
mean(mse_fix)
mean(mse_vary)
coverage_dual[[1]] %>% mean()
coverage_fix[[1]] %>% mean()
coverage_vary[[1]] %>% mean()
theta_upper_dual[[1]]
mean(theta_upper_dual[[1]] - theta_lower_dual[[1]])
mean(theta_upper_dual[[1]] - theta_lower_dual[[1]])
source('~/Desktop/Link to Research/trend_filtering/Code/btf_sim_study.R', echo=TRUE)
source('~/Desktop/Link to Research/trend_filtering/Code/btf_sim_study.R', echo=TRUE)
source('~/Desktop/Link to Research/trend_filtering/Code/btf_sim_study.R', echo=TRUE)
466 / 60
8 * 500
8 * 500 / 24
dual_time
btf_time
418 / 60
paste0("sim_n_", n_dat)
paste0("sim_n_", n_dat, ".RData")
source('~/Desktop/Link to Research/trend_filtering/Code/btf_sim_study.R', echo=TRUE)
install.packages("rstan", repos = "https://cloud.r-project.org/", dependencies=TRUE)
Rcpp::sourceCpp('Desktop/test.cpp')
Rcpp::sourceCpp('Desktop/test.cpp')
Rcpp::sourceCpp('Desktop/test.cpp')
library(microbenchmark)
n1 = n2 = 100
x = matrix(nrow = n1, ncol = n2, rnorm(n1 * n2))
y = t(x) %*% x
chol(y)
Rcpp::sourceCpp('Desktop/test.cpp')
Rcpp::sourceCpp('Desktop/test.cpp')
Rcpp::sourceCpp('Desktop/test.cpp')
library(microbenchmark)
n1 = n2 = 1000
x = matrix(nrow = n1, ncol = n2, rnorm(n1 * n2))
y = t(x) %*% x
microbenchmark(
chol(y),
chol_cpp(y)
)
z = chol(y)
str(z)
typeof(z)
as.matrix(z) -> z
typeof(z)
str(z)
?select
library(dplyr)
?select
slect
select
n = length(y)
diff_mat = myGetDkn(k, n)
rm(list = ls())
setwd("~/Dropbox/Research/tmvn/")
source("../trend_filtering/Code/btf_gibbs.R")
source("../trend_filtering/Code/btf_helpers.R")
source("../trend_filtering/Code/btf_dual.R")
library(dplyr)
library(lars)
library(mvtnorm)
library(tmvn)
# function to simulate the data
f_x = function(x)
{
exp(-7.5 * x) * cos(10 * pi * x)
}
# fix k, sd of sim data, and lambda
k = 2
fix_lambda = 2.5
fix_sd = 0.1
n_dat = 12
# simulating the data
seq_x = seq(0, 1, length = n_dat[1])
truth = f_x(seq_x)
set.seed(1234)
y = truth + rnorm(n_dat, mean = 0, sd = fix_sd)
lambda = 2
verbose = T
iters = 200
burn_in = iters / 2
n = length(y)
diff_mat = myGetDkn(k, n)
X = t(diff_mat)
# priors for a, b
b_prior = var(y)
a_prior = 2.01
# initializing the matricies to store the results
theta = matrix(nrow = iters, ncol = n, NA)
nu = matrix(nrow = iters, ncol = n - k, NA)
V_post_inv = diag(n - k) + t(X) %*% X
V_post = chol2inv(chol(V_post_inv))
mu_post = V_post %*% (t(X) %*% y)
a_post = a_prior + n/2
b_post = b_prior + 1/2 * (t(y) %*% y - t(mu_post) %*% V_post_inv %*% mu_post)
chol_V_post = t(chol(V_post))
# initial values
nu[1, ] = mu_post
theta[1, ] = y - t(diff_mat) %*% mu_post
set.seed(1234)
sigma2 = 1 / rgamma(iters, shape = a_post, rate = b_post)
i = 28
n_burn = 10
Mean = mu_post
Sigma = sigma2[i] * V_post
Sigma_chol = sqrt(sigma2[i]) * chol_V_post
D = diag(n_dat - k)
lower = rep(0, n_dat - k)
upper = rep(lambda, n_dat - k)
init = rep(lambda / 2, n_dat - k)
rtmvn_r(n = burn,
Mean = mu_post,
Sigma_chol = sqrt(sigma2[i]) * chol_V_post,
D = diag(n - k),
lower = rep(0, n - k),
upper = rep(lambda, n - k),
init = rep(lambda / 2, n - k))[, burn]
